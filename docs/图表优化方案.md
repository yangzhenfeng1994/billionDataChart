### 由于单页面内需要展示的数据量过大（单页面理论最大展示量为千万级），现做如下优化

1. 考虑到大部分情况下需要展示的只是指定区间段的数据，并不需要展示所有数据，通过滑动窗口 + 缓存算法过滤第一次数据量
2. 由于过滤后仍然存在数据较大的情况，理论上屏幕最多可展示数据量为 图表宽度的物理像素量，超出的数据量已经无法展示，因此可以通过降采样算法来进一步过滤数据，常用的采样规则有如下几种
     a)取区间段最大值
     b)取区间段最小值
     c)取区间段平均值
     d)取区间段总和
     e)设定阈值，超过阈值波动的所有值采用一定策略最大程度保留
   其中效果最好的应该为 e,但是也是耗费性能最多的，根据开发实际情况测试最终执行方案
3. 考虑到会展示同时展示多个图表，最终高度会超过一屏的展示上限，所以对于超出视口的图表采用虚拟列表优化方案，保留当前视口上下界外 50% 的余量，其余图表进行隐藏，减少计算量，等合适的时候再进行预加载
4. 考虑到操作频率，用户可能会高频拖动里程展示条，高频刷新数据，对全后端性能造成较大影响，用户操作事件上采用防抖算法，通过事件队列去除重复项，在保证用户体验的同时尽可能减少对于数据刷新造成的资源浪费
5. 考虑到数据计算，由于数据量较大对客户端和服务端的性能影响较大，浏览器本身是单线程运行，大量数据运算可能会造成阻塞，影响用户体验，因此采用web worker进行数据处理，通过 worker 线程进行较大数据量的运算，保证主线程的流畅性
6. 考虑到事件绑定，由于图表数量较多，可以考虑采用事件委托机制，通过对于父级组件的事件监听来统一接受，处理图表响应事件，包括拖动，点击等
7. 考虑到多组件数据传递、通过订阅发布模式，对列循环处理，优先保证在视口范围内的组件实时刷新，视口范围外的组件延迟刷新，尽量提升用户体验
8. 考虑到数据加工，采用工厂模式统一处理图表数据，统一优化数据处理算法与效率
9. 考虑到数据传输，结合上述算法，采用分段加载数据的方式，优先加载视口内，可展示部分数据，再通过反向推导的方式加载全部数据，缓存到内存中备用
10. 追加数据增量更新,较少需要传输的数据量
11. 数据传输采用二进制传输,减少数据量
12. 增加绘制缓存区域,拿过来直接用
13. 批量调用接口获取数据/通过 socket 流传输数据分批加载
14. 数据采用 indexDB 缓存,防止 localstorage 过大无法存储的问题
